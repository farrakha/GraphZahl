
import Foundation
import GraphQL
import NIO
import ContextKit

%{ import string }%
%{ allowedNumberOfTypes = 20 }%
%{ names = list(string.ascii_lowercase) }%

% for numberOfTypes in range(2, allowedNumberOfTypes + 1):
%{ types = [names[i].upper() for i in range(numberOfTypes)] }%
%{ typeInstances = [type + ".self" for type in types] }%
enum Union${numberOfTypes}<${", ".join(types)}> {
    % for i in range(numberOfTypes):
    case ${names[i]}(${names[i].upper()})
    % end
}

%{ resolvableConformances = [type + ": Resolvable" for type in types] }%
extension Union${numberOfTypes}: Resolvable where ${", ".join(resolvableConformances)} { }

%{ concreteResolvableConformances = [type + ": ConcreteResolvable" for type in types] }%
extension Union${numberOfTypes}: ConcreteResolvable where ${", ".join(concreteResolvableConformances)} {

    static var concreteTypeName: String {
        let types: [ConcreteResolvable.Type] = [${", ".join(typeInstances)}]
        return "Union" + types.map { $0.concreteTypeName }.joined(separator: "Or")
    }

}

%{ objectConformances = [type + ": GraphQLObject" for type in types] }%
extension Union${numberOfTypes}: OutputResolvable where ${", ".join(objectConformances)} {
    static var additionalArguments: [String : InputResolvable.Type] {
        return [:]
    }

    func resolve(source: Any, arguments: [String : Map], context: MutableContext, eventLoop: EventLoopGroup) throws -> EventLoopFuture<Any?> {
        switch self {
        % for i in range(numberOfTypes):
        case .${names[i]}(let object):
            return try object.resolve(source: source, arguments: arguments, context: context, eventLoop: eventLoop)
        % end
        }
    }

    static func resolve(using context: inout Resolution.Context) throws -> GraphQLOutputType {
        let name = concreteTypeName
        context.append(type: GraphQLTypeReference(name), as: name)
        let types: [GraphQLObject.Type] = [${", ".join(typeInstances)}]
        let outputs = try types.map { try $0.resolveObject(using: &context) }
        let resolveType: GraphQLTypeResolve = { value, _, _ in
            switch value as! Union${numberOfTypes} {
                % for i in range(numberOfTypes):
                case .${names[i]}:
                    return outputs[${i}]
                % end
            }
        }
        return GraphQLNonNull(try GraphQLUnionType(name: name,
                                                   description: nil,
                                                   resolveType: resolveType,
                                                   types: outputs))
    }
}
% end
