// This file was automatically generated and should not be edited.

import Runtime
import CContext

%{
    def _combos(elements, start_idx, length):
        # ignore elements before start_idx
        for i in range(start_idx, len(elements)):
            elem, count = elements[i]
            if count == 0:
                continue
            # base case: only one element needed
            if length == 1:
                yield (elem,)
            else:
                # need more than one elem: mutate the list and recurse
                elements[i] = (elem, count - 1)
                # when we recurse, we ignore elements before this one
                # this ensures we find combinations, not permutations
                for combo in _combos(elements, i, length - 1):
                    yield (elem,) + combo
                # fix the list
                elements[i] = (elem, count)


    def combos(elements, length):
        elements = list(elements.items())
        return _combos(elements, 0, length)

    allowedArguments = 14

    allowedTypes = { "int" : "Int", "float" : "Double"  }
    allowedArgumentMap = { "int" : 6, "float" : 8 }
}%

extension MethodInfo {

    func call(receiver: AnyObject, arguments: [Any]) throws -> Any {
        assert(arguments.count == self.arguments.count, "Argument count must correspond to original argument count")

        let arguments = try zip(arguments, self.arguments).flatMap { try resolveArguments(for: $0.0, using: $0.1.type) }.ordered()

        switch arguments.count {
        % for numberOfArguments in range(allowedArguments + 1):
        case ${numberOfArguments}:
            return try callWith${numberOfArguments}(receiver: receiver, arguments: arguments)
        % end
        default:
            fatalError("Calls with more than \(MethodInfo.maximumNumberOfArgumentsWithReflection) arguments are not allowed")
        }
    }

}

extension MethodInfo {

    % for numberOfArguments in range(allowedArguments + 1):
    private func callWith${numberOfArguments}(receiver: AnyObject, arguments: [FunctionArgument]) throws -> Any {
        switch (
            receiver
            % for index in range(numberOfArguments):
            , arguments[${index}]
            % end
        ) {

        %{ combinations = combos(allowedArgumentMap, numberOfArguments) }%
        % for arguments in combinations:

        case (
            _
            % for index, type in enumerate(arguments):
            , .${type}(let arg${index})
            % end
        ):
            %{ types = ", ".join([allowedTypes[x] for x in arguments]) }%
            let function = unsafeBitCast(address, to: (@convention(c) (${types}) -> Any).self)

            % for index, type in enumerate(arguments):
            let arg${index}Casted = arg${index}.value
            % end

            let selfPointer = Unmanaged.passUnretained(self).toOpaque()
            let receiverPointer = Unmanaged.passUnretained(receiver).toOpaque()
            set_self_pointer(receiverPointer)
            defer { set_self_pointer(selfPointer) }
            %{ argumentString = ", ".join(["arg" + str(i) + "Casted"  for i in range(numberOfArguments)]) }%
            return function(${argumentString})

        % end

        default:
            fatalError()
        }
    }
    % end

}

extension MethodInfo {

    static let maximumNumberOfArgumentsWithReflection = ${allowedArguments}

}
