// This file was automatically generated and should not be edited.

import Runtime
import CContext

%{
    import itertools

    allowedArguments = 5

    sizesDict = { 0 : "AnyObject", 1 : "Bool", 4 : "Float", 8 : "Int", 16 : "String" }
    sizes = sizesDict.keys()
}%

extension MethodInfo {

    func call(receiver: AnyObject, arguments: [Any]) throws -> Any {
        assert(arguments.count == self.arguments.count, "Argument count must correspond to original argument count")

        switch arguments.count {
        % for numberOfArguments in range(allowedArguments + 1):
        case ${numberOfArguments}:
            return try callWith${numberOfArguments}(receiver: receiver, arguments: arguments)
        % end
        default:
            fatalError("Calls with more than \(MethodInfo.maximumNumberOfArgumentsWithReflection) arguments are not allowed")
        }
    }

}

extension MethodInfo {

    % for numberOfArguments in range(allowedArguments + 1):
    private func callWith${numberOfArguments}(receiver: AnyObject, arguments: [Any]) throws -> Any {
        switch (
            receiver
            % for index in range(numberOfArguments):
            , try sizeEstimation(of: self.arguments[${index}].type)
            % end
            , try sizeEstimation(of: returnType)
        ) {

        % for permutation in itertools.product(sizes, repeat=numberOfArguments + 1):

        case (
            _
            % for size in permutation:
            , ${size}
            % end
        ):
            %{ arguments = permutation[:-1] }%
            %{ returnType = sizesDict[permutation[-1]] }%
            %{ types = ", ".join([sizesDict[x] for x in arguments]) }%
            let function = unsafeBitCast(address, to: (@convention(c) (${types}) -> ${returnType}).self)

            % for index, size in enumerate(arguments):
            let arg${index} = safeishCast(value: arguments[${index}], to: ${ sizesDict[size] }.self)
            % end

            let selfPointer = Unmanaged.passUnretained(self).toOpaque()
            let receiverPointer = Unmanaged.passUnretained(receiver).toOpaque()
            set_self_pointer(receiverPointer)
            defer { set_self_pointer(selfPointer) }
            %{ argumentString = ",".join(["arg" + str(i) for i in range(numberOfArguments)]) }%
            return function(${argumentString})

        % end

        default:
            fatalError()
        }
    }
    % end

}

extension MethodInfo {

    static let maximumNumberOfArgumentsWithReflection = ${allowedArguments}

}

private func sizeEstimation(of type: Any.Type) -> Int {
    let info = typeInfo(of: type)
    switch info.kind {
    case .class:
        return 0
    default:
        return info.size
    }
}

private func safeishCast<T>(value: Any, to type: T.Type) -> T {
    return withUnsafeBytes(of: value) { $0.baseAddress!.load(as: type) }
}
