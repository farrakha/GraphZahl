
import Foundation
import CContext
import Runtime
%{ int_types = ["Bool", "Int8", "Int16", "Int32", "Int"] }%
%{ float_types = ["Float", "Double"] }%

enum IntArgument {
    % for swiftType in int_types:
    case ${swiftType.lower()}(${swiftType})
    % end
    case pointer(UnsafeMutableRawPointer)

    var value: Int {
        switch self {
        % for swiftType in int_types:
        case .${swiftType.lower()}(let value):
            return Int(from: value)
        % end
        case .pointer(let value):
            return Int(from: value)
        }
    }
}

enum FloatArgument {
    % for swiftType in float_types:
    case ${swiftType.lower()}(${swiftType})
    % end

    var value: Double {
        switch self {
        % for swiftType in float_types:
        case .${swiftType.lower()}(let value):
            return Double(from: value)
        % end
        }
    }
}

enum FunctionArgument {
    case int(IntArgument)
    case float(FloatArgument)
}

func resolveArguments(for value: Any, using type: Any.Type) throws -> [FunctionArgument] {
    % for swiftType in int_types:
    if type == ${swiftType}.self {
        return [.int(.${swiftType.lower()}(value as! ${swiftType}))]
    }
    % end
    % for swiftType in float_types:
    if type == ${swiftType}.self {
        return [.float(.${swiftType.lower()}(value as! ${swiftType}))]
    }
    % end

    // Special cases
    if type == String.self {
        let bytes = withUnsafeBytes(of: value as! String) { $0.bindMemory(to: Int.self) }
        return Array(bytes).map { .int(.int($0)) }
    }

    let info = try typeInfo(of: type)
    switch info.kind {
    case .class:
        return [.int(.pointer(Unmanaged.passUnretained(value as AnyObject).toOpaque()))]
    case .optional:
        let actualType = info.genericTypes.first!
        return try resolveArguments(for: value, using: actualType)
    default:
        return try info.properties.flatMap { try resolveArguments(for: $0.get(from: value), using: $0.type) }
    }
}

extension Sequence where Element == FunctionArgument {

    func ordered() -> [FunctionArgument] {
        return sorted { lhs, rhs in
            switch (lhs, rhs) {
            case (.int, .int), (.float, .float), (.int, .float):
                return true
            case (.float, .int):
                return false
            }
        }
    }

}

extension Int {

    fileprivate init<T>(from transformable: T) {
        let pointer = UnsafeMutableRawPointer.allocate(byteCount: MemoryLayout<Int>.size, alignment: MemoryLayout<Int>.alignment)
        pointer.storeBytes(of: transformable, as: T.self)
        self = pointer.load(as: Int.self)
    }

}

extension Double {

    fileprivate init<T>(from transformable: T) {
        let pointer = UnsafeMutableRawPointer.allocate(byteCount: MemoryLayout<Double>.size, alignment: MemoryLayout<Double>.alignment)
        pointer.storeBytes(of: transformable, as: T.self)
        self = pointer.load(as: Double.self)
    }

}
